#include "astnode.h"
#define ENABLE_OPT1 1 //evaluating constant expressions
#define ENABLE_OPT2 1 //evaluating constant expressions

int tmpCount = 1;
string getNextTemp(){
	ostringstream newReg;
	newReg << "$" << "T" << tmpCount++;
	return newReg.str();
}
string getOpcodeString(Opcode opcode){
	string code[] =  {"ADDI", "ADDF", "SUBI", "SUBF", "MULTI", "MULTF", "DIVI", "DIVF", "STOREI", "STOREF", "GT", "GE", "LT", "LE", "NE", "EQ", "JUMP", "LABEL", "READI", "READF", "WRITEI", "WRITEF"};
	return code[opcode];
}

string convertCodetoString(vector<IRNode> code){
	ostringstream oss;
	for(vector<IRNode>::iterator i = code.begin(); i != code.end(); ++i){
		oss << (*i).toIRString() << endl;
	}
	return oss.str();
}

void removedRedundentIRs(vector<IRNode> & in){

	while(true){

		bool reduced=false;
		for(int i=0; i<in.size(); i++){
			if(in[i].opcode!=Opcode::READF && in[i].opcode!=Opcode::READI && in[i].getDef().size()!=0){//eventhough a read might be redundent we must do it
				string def=in[i].getDef();
				bool removeItem=false;
				int j;
				for( j=i+1;j<in.size(); j++){
					if(in[j].isAUse(def))
						break;
					else if(in[j].isDef(def))
					{
						removeItem=true;
						break;
					}
				}
				if(removeItem || j==in.size()){
					//remove the item
					in.erase(in.begin()+i);
					reduced=true;
					break;
				}
				else
					continue;
			}
		}
		if (reduced)
			continue;
		else
			return;
	}
}

string IRNode::getDef(){
	switch (this->opcode) {
	case Opcode::ADDI:
	case Opcode::ADDF:
	case Opcode::SUBI:
	case Opcode::SUBF:
	case Opcode::MULTI:
	case Opcode::MULTF:
	case Opcode::DIVI:
	case Opcode::DIVF:
	case Opcode::STOREI:
	case Opcode::STOREF:
	case Opcode::READI:
	case Opcode::READF:

		return this->op3;
		break;
	default:
		return "";
		break;
	}
}

bool IRNode::isDef(string def){
	if(def.compare(getDef())==0)
		return true;
	else return false;

}
bool IRNode::isAUse(string reg){
	switch (opcode) {
	case Opcode::ADDI:
	case Opcode::ADDF:
	case Opcode::SUBI:
	case Opcode::SUBF:
	case Opcode::MULTI:
	case Opcode::MULTF:
	case Opcode::DIVI:
	case Opcode::DIVF:
	case Opcode::GT:
	case Opcode::GE:
	case Opcode::LT:
	case Opcode::LE:
	case Opcode::NE:
	case Opcode::EQ:
		if(this->op1.compare(reg)==0 ||this->op2.compare(reg)==0 )
			return true;
		else
			return false;

		break;
	case Opcode::STOREI:
	case Opcode::STOREF:
		if(this->op1.compare(reg)==0 )
			return true;
		else
			return false;

		break;


	case WRITEF:
	case WRITEI:
		if(this->op3.compare(reg)==0 )
			return true;
		else
			return false;

		break;
	default:
		return false;
	}
}
string IRNode::toIRString(){
	string code;
	code.append(getOpcodeString(opcode));

	if(!op1.empty()){
		code.append(" ");
		code.append(op1);
	}
	if(!op2.empty()){
		code.append(" ");
		code.append(op2);
	}
	if(!op3.empty()){
		code.append(" ");
		code.append(op3);
	}
	return code;
}


string IRNode::toAssemblyString(){
	return "";
}

vector<IRNode> StatementList::genCode(){
	vector<IRNode> code;

	vector<IRNode> lcode = left->genCode();
	code.insert(code.end(), lcode.begin(), lcode.end());

	if(right != NULL){
		vector<IRNode> rcode = right->genCode();
		code.insert(code.end(), rcode.begin(), rcode.end());

	}

	return code;
}

//opt 1 done
vector<IRNode> AssignStatement::genCode(){

	vector<IRNode> code;
	Identifier * leftId=dynamic_cast<Identifier *>(this->left);
	vector<IRNode> lcode = left->genCode();
	vector<IRNode> rcode = right->genCode();

	if(ENABLE_OPT1==1 && right->hasImmediateValue()){
		;//do not append right side code
		if(this->valType==SymbolEntryType::INT)
			code.push_back(IRNode(Opcode::STOREI,right->getImmediateValueAsString(),"",leftId->name));

		else if(this->valType==SymbolEntryType::FLOAT)
			code.push_back(IRNode(Opcode::STOREF,right->getImmediateValueAsString(),"",leftId->name));

		leftId->scope->updateIdValue(leftId->name,right->getImmediateValue());


	}else{

		code.insert(code.end(), rcode.begin(), rcode.end());

		if(this->valType==SymbolEntryType::INT)
			code.push_back(IRNode(Opcode::STOREI,this->right->getTempVAl(),"",leftId->name));

		else if(this->valType==SymbolEntryType::FLOAT)
			code.push_back(IRNode(Opcode::STOREF,this->right->getTempVAl(),"",leftId->name));

		leftId->scope->cancelIdValue(leftId->name);

		if(ENABLE_OPT2==1){
			leftId->scope->updateIdTempValue(leftId->name,right->getTempVAl());
		}

	}


	return code;
}

vector<IRNode> Identifier::genCode(){
	vector<IRNode> code;
	return code;
}


// opt 1 done
vector<IRNode> Constant::genCode(){
	vector<IRNode> code;

	if(ENABLE_OPT1==1){
		//no need to move the value into register
		if(valType==SymbolEntryType::FLOAT)
			immediateVal.floatVal=stof(valAsString);
		else
			immediateVal.intval=stoi(valAsString);
	}
	else {
		cout<<"gen code for costant :"<<this->valAsString<<endl;
		this->tempVal=getNextTemp();
		if(this->valType==SymbolEntryType::INT)
			code.push_back(IRNode(STOREI, this->valAsString, "",this->tempVal ));
		else
			code.push_back(IRNode(STOREF, this->valAsString, "",this->tempVal ));
	}
	return code;
}

vector<IRNode> IOCommand::genCode(){
	vector<IRNode> code;
	for(int i=0; i<this->idList.size(); i++){
		Identifier * tmp=dynamic_cast<Identifier *>(idList[i]);

		if(isRead){
			if(tmp->valType==SymbolEntryType::INT)
				code.push_back(IRNode(READI,"","",tmp->name));
			else
				code.push_back(IRNode(READF,"","",tmp->name));

			tmp->scope->cancelIdValue(tmp->name);
			tmp->scope->cancelIdTempValue(tmp->name);
		}
		else{
			if(tmp->valType==SymbolEntryType::INT)
				code.push_back(IRNode(WRITEI,"","",tmp->name));
			else
				code.push_back(IRNode(WRITEF,"","",tmp->name));
		}
	}

	return code;
}

vector<IRNode> Binop::genCode(){
	vector<IRNode> code;
	vector<IRNode> lcode = left->genCode();
	vector<IRNode> rcode = right->genCode();

	if(ENABLE_OPT1==1 &&(left->hasImmediateValue() || right->hasImmediateValue())  ){

		//cout<<"left val"<<left->getImmediateValue().floatVal<<"right val"<<right->getImmediateValue().floatVal<<endl;
		//if both right and left side are known
		if(right->hasImmediateValue()&& left->hasImmediateValue()){
			this->valueKnown=true;

			switch (this->operationType) {
			case BINOPType::ADD:
				if(valType==FLOAT)
					this->setImmediateValue(right->getImmediateValue().floatVal + left->getImmediateValue().floatVal);
				else
					this->setImmediateValue(right->getImmediateValue().intval+left->getImmediateValue().intval);

				break;
			case BINOPType::SUB:
				if(valType==FLOAT)
					this->setImmediateValue(left->getImmediateValue().floatVal-right->getImmediateValue().floatVal);
				else
					this->setImmediateValue(left->getImmediateValue().intval-right->getImmediateValue().intval);
				break;
			case BINOPType::MUL:
				if(valType==FLOAT){
					this->setImmediateValue(right->getImmediateValue().floatVal*left->getImmediateValue().floatVal);
				}else
					this->setImmediateValue(right->getImmediateValue().intval*left->getImmediateValue().intval);
				break;
			case BINOPType::DIV:
				if(valType==FLOAT)
					this->setImmediateValue(left->getImmediateValue().floatVal/right->getImmediateValue().floatVal);
				else
					this->setImmediateValue(left->getImmediateValue().intval/right->getImmediateValue().intval);

				break;
			default:
				break;
			}
		}
		else{
			string leftOp,rightOp,res;
			if(!right->hasImmediateValue()){
				code.insert(code.end(), rcode.begin(), rcode.end());
				rightOp=right->getTempVAl();
			}
			else{
				rightOp=right->getImmediateValueAsString();
			}

			if(!left->hasImmediateValue()){
				code.insert(code.end(), lcode.begin(), lcode.end());
				leftOp=left->getTempVAl();
			}
			else{
				leftOp=left->getImmediateValueAsString();
			}
			res=getNextTemp();
			this->tempVal=res;
			switch (this->operationType) {
			case BINOPType::ADD:
				if(this->valType==SymbolEntryType::INT)
					code.push_back(IRNode(ADDI,leftOp,rightOp,res));
				else
					code.push_back (IRNode(ADDF,leftOp,rightOp,res));
				break;
			case BINOPType::SUB:
				if(this->valType==SymbolEntryType::INT)
					code.push_back(IRNode(SUBI,leftOp,rightOp,res));
				else
					code.push_back(IRNode(SUBF,leftOp,rightOp,res));
				break;
			case BINOPType::MUL:
				if(this->valType==SymbolEntryType::INT)
					code.push_back(IRNode(MULTI,leftOp,rightOp,res));
				else
					code.push_back(IRNode(MULTF,leftOp,rightOp,res));
				break;
			case BINOPType::DIV:
				if(this->valType==SymbolEntryType::INT)
					code.push_back(IRNode(DIVI,leftOp,rightOp,res));
				else
					code.push_back(IRNode(DIVF,leftOp,rightOp,res));
				break;
			default:
				break;
			}
		}
	}
	else{//no optimizations
		string leftOp,rightOp,res;

		code.insert(code.end(), lcode.begin(), lcode.end());
		leftOp=left->getTempVAl();

		code.insert(code.end(), rcode.begin(), rcode.end());
		rightOp=right->getTempVAl();

		res=getNextTemp();
		this->tempVal=res;
		switch (this->operationType) {
		case BINOPType::ADD:
			if(this->valType==SymbolEntryType::INT)
				code.push_back(IRNode(ADDI,leftOp,rightOp,res));
			else
				code.push_back (IRNode(ADDF,leftOp,rightOp,res));
			break;
		case BINOPType::SUB:
			if(this->valType==SymbolEntryType::INT)
				code.push_back(IRNode(SUBI,leftOp,rightOp,res));
			else
				code.push_back(IRNode(SUBF,leftOp,rightOp,res));
			break;
		case BINOPType::MUL:
			if(this->valType==SymbolEntryType::INT)
				code.push_back(IRNode(MULTI,leftOp,rightOp,res));
			else
				code.push_back(IRNode(MULTF,leftOp,rightOp,res));
			break;
		case BINOPType::DIV:
			if(this->valType==SymbolEntryType::INT)
				code.push_back(IRNode(DIVI,leftOp,rightOp,res));
			else
				code.push_back(IRNode(DIVF,leftOp,rightOp,res));
			break;
		default:
			break;
		}
	}
	return code;
}


//opt1
bool Constant::hasImmediateValue(){
	return true;
}

bool Identifier::hasImmediateValue(){
	return scope->getIdInfo(this->name).valueKnown;
}

bool Binop::hasImmediateValue(){
	return this->valueKnown;
}

ValueHolder Identifier::getImmediateValue(){
	if(! scope->getIdInfo(this->name).valueKnown)
		;
	return scope->getIdInfo(this->name).val;
}

string Identifier::getTempVAl(){
	if(ENABLE_OPT2==1)
		return scope->getIdInfo(this->name).tempVal;
	else
		return name;

}
